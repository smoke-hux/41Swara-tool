// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/metatx/MinimalForwarder.sol";
import "@openzeppelin/contracts/metatx/ERC2771Context.sol";

/**
 * Test contract for 2025 OWASP Smart Contract Top 10 vulnerabilities
 * Contains vulnerable patterns for testing the scanner
 */
contract TestVulnerable2025 {

    // =====================================
    // FLASH LOAN VULNERABILITY (OWASP #4)
    // =====================================

    // Vulnerable: Flash loan callback without validation
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // BUG: No validation of msg.sender or initiator
        // Attacker can call this directly
        doSomethingDangerous(amounts[0]);
        return true;
    }

    // Vulnerable: Using balanceOf for pricing (flash loan manipulable)
    function getPrice(address token) external view returns (uint256 price) {
        uint256 balance = IERC20(token).balanceOf(address(this));
        price = balance * 1e18 / totalSupply;  // Manipulable via flash loans
    }

    // =====================================
    // LOGIC ERROR (OWASP #2)
    // =====================================

    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    // Vulnerable: First depositor attack in vault
    function deposit(uint256 assets) external {
        uint256 shares;
        if (totalSupply == 0) {
            // BUG: First depositor can manipulate share price
            shares = assets;
        } else {
            shares = assets * totalSupply / totalAssets();
        }
        _mint(msg.sender, shares);
    }

    // Vulnerable: CEI violation
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient");

        // BUG: External call before state change
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);

        // State change AFTER external call - reentrancy!
        balances[msg.sender] -= amount;
    }

    // =====================================
    // META-TRANSACTION / KILOEX PATTERN
    // =====================================

    mapping(address => uint256) public _nonces;

    // Vulnerable: Execute without signature verification (KiloEx exploit)
    function execute(ForwardRequest calldata req) external returns (bool, bytes memory) {
        // BUG: No signature verification!
        // BUG: No nonce increment!
        // Attacker can forge requests
        (bool success, bytes memory returndata) = req.to.call{value: req.value}(req.data);
        return (success, returndata);
    }

    struct ForwardRequest {
        address from;
        address to;
        uint256 value;
        uint256 gas;
        uint256 nonce;
        bytes data;
    }

    // Vulnerable: Mutable trusted forwarder
    address public trustedForwarder;

    function setTrustedForwarder(address forwarder) external {
        // BUG: Anyone can change forwarder
        trustedForwarder = forwarder;
    }

    function _msgSender() internal view returns (address) {
        // Using ERC2771 context
        return msg.sender;
    }

    // =====================================
    // UNCHECKED MATH (CETUS PATTERN)
    // =====================================

    // Vulnerable: Custom safe math implementation
    function checkedShl(uint256 x, uint256 bits) internal pure returns (uint256) {
        // BUG: Flawed overflow check like Cetus
        return x << bits;  // No bounds validation!
    }

    // Vulnerable: Bit shift in unchecked block
    function calculateLiquidity(uint256 amount) internal pure returns (uint256 liquidity) {
        unchecked {
            // BUG: Bit shifts don't revert on overflow in unchecked
            liquidity = amount << 64;  // Can overflow!
            liquidity = liquidity + (amount >> 2);
        }
    }

    // Vulnerable: sqrt in unchecked
    function sqrtPrice(uint256 x) internal pure returns (uint256) {
        unchecked {
            // BUG: Complex math in unchecked
            return sqrt(x);
        }
    }

    // =====================================
    // GOVERNANCE ATTACK (BEANSTALK PATTERN)
    // =====================================

    mapping(uint256 => uint256) public proposalVotes;

    // Vulnerable: Voting without snapshot (flash loan attack)
    function castVote(uint256 proposalId, bool support) external {
        // BUG: No snapshot - voting power can be flash loaned
        uint256 votes = balanceOf(msg.sender);
        proposalVotes[proposalId] += support ? votes : 0;
    }

    // Vulnerable: Emergency without proper protection
    function emergencyWithdraw() external {
        // BUG: No multisig, no timelock
        payable(msg.sender).transfer(address(this).balance);
    }

    // =====================================
    // BRIDGE VULNERABILITY
    // =====================================

    // Vulnerable: Cross-chain handler without validation
    function lzReceive(uint16 srcChainId, bytes calldata payload) external {
        // BUG: No source chain validation
        // BUG: No trusted remote check
        (address to, uint256 amount) = abi.decode(payload, (address, uint256));
        _mint(to, amount);
    }

    // Vulnerable: Bridge claim without replay protection
    function claimBridged(bytes calldata proof, uint256 amount) external {
        // BUG: No replay protection - same proof can be used twice
        require(verifyProof(proof), "Invalid proof");
        _mint(msg.sender, amount);
    }

    // =====================================
    // ACCESS CONTROL (OWASP #1)
    // =====================================

    // Vulnerable: Unprotected initializer
    function initialize(address owner) external {
        // BUG: Can be called multiple times
        _owner = owner;
    }

    address private _owner;

    // Vulnerable: tx.origin authentication
    function transferAll(address to) external {
        require(tx.origin == _owner, "Not owner");  // BUG: Phishing attack
        payable(to).transfer(address(this).balance);
    }

    // =====================================
    // LIQUIDITY MANIPULATION
    // =====================================

    // Vulnerable: First depositor attack vector
    function addLiquidity(uint256 amount) external {
        if (totalSupply == 0) {
            // BUG: No virtual shares protection
            _mint(msg.sender, amount);
        }
    }

    // =====================================
    // HELPER FUNCTIONS (not vulnerable, just for compilation)
    // =====================================

    function totalAssets() public view returns (uint256) {
        return address(this).balance;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _mint(address to, uint256 amount) internal {
        balances[to] += amount;
        totalSupply += amount;
    }

    function doSomethingDangerous(uint256 amount) internal {}

    function sqrt(uint256 x) internal pure returns (uint256 y) {
        y = x;
    }

    function verifyProof(bytes calldata) internal pure returns (bool) {
        return true;
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
}
